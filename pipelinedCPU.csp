#import "PAT.Lib.Array";

// used in IF stage
var pc = -1;
var pcSeq = -1;

// the idea for those TRANS_ variables is that,
// within a clock cycle, every stage should be independent of each other.
// the state is transferred after all the stages.

// used in ID stage
var instr = -1;
var trans_instr = -1;

// used in EXE stage
var cmd = -1;
var op1 = -1;
var op2 = -1;
var op2_index = -1;
var op3 = -1;
var alu_out = -1;
var trans_cmd = -1;
var trans_op1 = -1;
var trans_op2 = -1;
var trans_op3 = -1;
var trans_alu_out = -1;

// no MEM stage yet
var mem[31];
var memSeq[64];

// used in WB stage
var write_back_register = -1;
var trans_write_back_register = -1;

// registers
var r[31];

// ALU supported operators (commands):
// add(1), minus(2), multiply(3), divide(4),
// 
// basic form: operator, op1, op2, op3
// means that op2 operator op3 = (assign to) op1
// e.g.
// add, r1, r2, r3
// means that r2 + r3 = r1
//
// digit form:
// 1st digit - operator
// 2nd digit - op1 (where the result assigns to)
// 3rd digit - op2
// 4th digit - op3
// e.g.
// 1123 means add, r1, r2, r3 in the basic form

// proposed program to demo data hazard
var program = [	
	/*
	15030203, // if r2 != r3, goto #d
	11010203, // r2 + r3 = r1
	12030402  // r4 - r2 = r3
	*/
	//18020400
	
	/*
	// Test jump
	17080000, // jump to line 8 (start from 0)
	10000001, // noop 1
	10000002, // noop 2
	10000003, // noop 3
	11010203, // r2+r3 = r1
	10000004, // noop 4
	10000005, // noop 5
	10000006, // noop 6
	11010103  // r1+r3 = r1   -> Jump to here <-
	*/
	
	/*
	// Test BEQ
	15080101, // jump to line 8 (start from 0)
	10000001, // noop 1
	10000002, // noop 2
	10000003, // noop 3
	11010203, // r2+r3 = r1
	10000004, // noop 4
	10000005, // noop 5
	10000006, // noop 6
	11010103  // r1+r3 = r1   -> Jump to here <-
	// r1 = 6 TRUE
	*/
	
	
	// Test BNE
	16080102, // jump to line 8 (start from 0)
	10000001, // noop 1
	10000002, // noop 2
	10000003, // noop 3
	11010203, // r2+r3 = r1
	10000004, // noop 4
	10000005, // noop 5
	10000006, // noop 6
	11010103  // r1+r3 = r1   -> Jump to here <-
	// r1 = 1 TRUE
	
];

// expected (FAIL)
//#define goal  r[4] == 4;
// actual (PASS)
#define goal  r[1] == 6;

// normal demo
//var program = [
//	1123  // r2 + r3 = r1
//];
//#define goal  r[1] == 7;



var programSeq = [
/*
// Test Add, Sub
11030102, // r1+r2=r3
12040302, //r3-r2=r4
11050104, // r1+r4=r5
11060205 // r2+r5=r6
*/

/*
// Test Mult, Div
13020101, // r1*r1=r2
14010402 // r4/r2=r1
*/

/*
// Test BEQ
15030102, // If r1=r2, jump to the 3th instr starting from 0
11030405, //r4+r5=r3
12030605, // r6-r5=r3
13030406, // r4*r6=r3     <----- Jump to here
13030506 // r5*r6=r3
*/

/*
// Test BNQ
16030102, // If r1!=r2, jump to the 3th instr starting from 0
11030405, //r4+r5=r3
12030605, // r6-r5=r3
13030406, // r4*r6=r3     <----- Jump to here
13030506 // r5*r6=r3
*/

/*
// Test Jump
17030000, //Jump to the 3th instr starting from 0
11030405, //r4+r5=r3
12030605, // r6-r5=r3
13030406, // r4*r6=r3     <----- Jump to here
13030506 // r5*r6=r3
*/

/*
//Test Save and Load
20100300,// Save r3's value to mem[10]
19021000 // Load value from mem[10] to r2
*/

//Test Move
18020900 // Assign value 9 to r2
];

#define goalSeq  r[2]==9;

InitializeSeq() = INITSeq {
	r[1] = 2;
	r[2] = 3;
	r[3] = 4;
	r[4] = 5;
	r[5] = 7;
	r[6] = 8;
	var i = 0;
	while(i<64){
		memSeq[i]=0;
		i++;
	}
	
} -> Skip;

Initialize() = INIT {
	r[1] = 2;
	r[2] = 3;
	r[3] = 4;
	r[4] = 5;
	r[5] = 7;
	r[6] = 8;
} -> Skip;

/******************************************
 * Sequential CPU
********************************************/
SequentialInstrClk() =clk->{
	//IF
	if (pcSeq + 1 < call(ArrayLength, program)) {
		pcSeq++;
		instr = programSeq[pcSeq];
	} else {
		instr = -1;
	}
	//ID
	if (instr != -1) {
		// extract op3
		op3 = r[instr % 100];
		instr = instr / 100;
		// extract op2
		op2 = r[instr % 100];
		op2_index = instr % 100;
		instr = instr / 100;
		// extract op1
		op1 = instr % 100;
		instr = instr / 100;
		// extract cmd
		cmd = instr;
	} else {
		cmd = -1;
		op1 = -1;
		op2 = -1;
		op3 = -1;
	}
	//EXE
	if (cmd != -1) {
		if (cmd == 10) { // NOOP
			// do nothing
			alu_out = alu_out;
		} else if (cmd == 11) { // ADD
			alu_out = op2 + op3;
			write_back_register = op1;
		} else if (cmd == 12) { // SUB
			alu_out = op2 - op3;
			write_back_register = op1;
		} else if (cmd == 13) { // MULT
			alu_out = op2 * op3;
			write_back_register = op1;
		} else if (cmd == 14) { // DIV
			alu_out = op2 / op3;  // could be div-zero exception
			write_back_register = op1;
		} else if (cmd == 15) { // BEQ
			if( op2 == op3){
				pcSeq = op1 - 1;
			}
			write_back_register = -1;
		} else if (cmd == 16) { // BNE
			if( op2 != op3){
				pcSeq = op1 - 1;
			}
			write_back_register = -1;
		} else if (cmd == 17) { // JUMP
			pcSeq = op1 - 1;
			write_back_register = -1;
			// need to flush
		} else if (cmd == 18) { // MOVE
			r[op1] = op2_index;
		} else if (cmd == 19) { // LOAD
			r[op1] = memSeq[op2_index];
			write_back_register = -1;
			//alu_out = memSeq[op2];
		} else if (cmd == 20) { // SAVE
			// ??
			memSeq[op1] = op2;
			write_back_register = -1;
		}// else {
			// unsupported command exception
		//}
	} else {
		write_back_register = -1;
	}
	//WB
	if (write_back_register != -1) {
		r[write_back_register] = alu_out;
	}
}->SequentialInstrClk();





/********************************************
 * IF Stage 
 ********************************************/
InstructionFetch() = clk -> IF {
	if (pc + 1 < call(ArrayLength, program)) {
		pc++;
		trans_instr = program[pc];
	} else {
		trans_instr = -1;
	}
} -> trans -> InstructionFetch();

IF2ID() = clk -> trans -> IF2ID_Trans {
	instr = trans_instr;
} -> IF2ID();

/********************************************
 * ID Stage 
 ********************************************/
InstructionDecode() = clk -> ID {
	if (instr != -1) {
		// extract op3
		trans_op3 = r[instr % 100];
		instr = instr / 100;
		// extract op2
		trans_op2 = r[instr % 100];
		instr = instr / 100;
		// extract op1
		trans_op1 = instr % 100;
		instr = instr / 100;
		// extract cmd
		trans_cmd = instr;
	} else {
		trans_cmd = -1;
		trans_op1 = -1;
		trans_op2 = -1;
		trans_op3 = -1;
	}
} -> trans -> InstructionDecode();

ID2EX() = clk -> trans -> ID2EX_Trans {
	cmd = trans_cmd;
	op1 = trans_op1;
	op2 = trans_op2;
	op3 = trans_op3;
} -> ID2EX();

/********************************************
 * EX Stage 
 ********************************************/
Execution() = clk -> EXE {
	if (cmd != -1) {
		if (cmd == 10) { // NOOP
			// do nothing
			trans_alu_out = trans_alu_out;
		} else if (cmd == 11) { // ADD
			trans_alu_out = op2 + op3;
			trans_write_back_register = op1;
		} else if (cmd == 12) { // SUB
			trans_alu_out = op2 - op3;
			trans_write_back_register = op1;
		} else if (cmd == 13) { // MULT
			trans_alu_out = op2 * op3;
			trans_write_back_register = op1;
		} else if (cmd == 14) { // DIV
			trans_alu_out = op2 / op3;  // could be div-zero exception
			trans_write_back_register = op1;
		} else if (cmd == 15) { // BEQ
			if( op2 == op3){
				pc = op1 - 1;
			}
			trans_write_back_register = -1;
		} else if (cmd == 16) { // BNE
			if( op2 != op3){
				pc = op1 - 1;
			}
			trans_write_back_register = -1;
		} else if (cmd == 17) { // JUMP
			pc = op1 - 1;
			trans_write_back_register = -1;
			// need to flush
		} else if (cmd == 18) { // MOVE
			trans_alu_out = op2;
		} else if (cmd == 19) { // LOAD
			trans_alu_out = mem[op2];
		} else if (cmd == 20) { // SAVE
			// ??
			mem[op1] = op2;
		}// else {
			// unsupported command exception
		//}
	} else {
		trans_write_back_register = -1;
	}
} -> trans -> Execution();

EX2WB() = clk -> trans -> EX2WB_Trans {
	alu_out = trans_alu_out;
	write_back_register = trans_write_back_register;
} -> EX2WB();

/********************************************
 * MEM Stage 
 ********************************************/
//no MEM stage yet
 
/********************************************
 * WB Stage 
 ********************************************/
WriteBack() = clk -> WB {
	if (write_back_register != -1) {
		r[write_back_register] = alu_out;
	}
} -> trans -> WriteBack();

/********************************************
 * Verification Program
 ********************************************/
StageTransition() = IF2ID() || ID2EX() || EX2WB();
Pipeline() = InstructionFetch() || InstructionDecode() || Execution() || WriteBack() || StageTransition();
CPU() = Initialize(); Pipeline();
SeqCPU() = InitializeSeq();SequentialInstrClk();
#assert CPU() reaches goal;
#assert SeqCPU() reaches goalSeq;