#import "PAT.Lib.Array";


//############################################
// Hardware
//############################################
// registers
var r[31];
// memory
var mem[64];


//############################################
// Variables
//############################################

// used in IF stage
var pc = -1;
var pcSeq = -1;

// the idea for those TRANS_ variables is that,
// within a clock cycle, every stage should be independent of each other.
// the state is transferred after all the stages.
var trans_pc = -1;

// used in ID stage
var instr = -1;

var trans_instr = -1;

// used in EXE stage
var cmd = -1;
var op1 = -1; // stores dest register index
var op2 = -1; // stores the 2nd register value
var op2_imm = -1;
var op2_register_index = -1;
var op3 = -1; // stores the 3rd register value
var op3_register_index = -1;
var alu_out = -1;

var trans_cmd = -1;
var trans_op1 = -1;
var trans_op2 = -1;
var trans_op2_imm = -1;
var trans_op2_register_index = -1;
var trans_op3 = -1;
var trans_op3_register_index = -1;
var trans_alu_out = -1;

// used in MEM stage
var memory_access = -1; // -1 - no access, 0 - read only, 1 - write only
var memory_addr = -1; // addr to read from or write to
var memory_value = -1; // value to read to or write from
var next_stage_write_back_register = -1;
var next_stage_write_back_value = -1;

var trans_memory_access = -1;
var trans_memory_addr = -1;
var trans_memory_value = -1;
var trans_next_stage_write_back_register = -1;
var trans_next_stage_write_back_value = -1;

// used in WB stage
var write_back_register = -1; // the register to write back to
var write_back_value = -1; // the value to write back to
var trans_write_back_register = -1;
var trans_write_back_value = -1;


//############################################
// Program
// this program tests all the instructions
//############################################

var program = [
	// Test Case: Branching
	18010100, // r1 = 1
	18020200, // r2 = 2
	18030200, // r3 = 2
	15070302, // jump to pc = 7, if r3 == r2
	18015500, // r1 = 55
	18025500, // r2 = 55
	18035500, // r3 = 55
	18042500, // r4 = 25 (got executed)
	16120102, // jump to pc = 12, if r1 != r2
	18015500, // r1 = 55
	18025500, // r2 = 55
	18035500, // r3 = 55
	18052500, // r5 = 25 (got executed)
	17170000, // jump to pc = 17
	18015500, // r1 = 55
	18025500, // r2 = 55
	18035500, // r3 = 55
	18062500, // r6 = 25 (got executed); PC = 17
	
	// Test Case: Basic operations
	18010100, // r1 = 1
	18020200, // r2 = 2
	11030102, // r3 = r1 + r2; r3 is 3
	12040302, // r4 = r3 - r2; r4 is 1
	13050302, // r5 = r3 * r2; r5 is 6
	10000000, // noop
	14060503, // r6 = r5 / r3; r6 is 2; PC = 24
	
	// Test Case: Memory Access
	18011500, // r1 = 15
	20010100, // mem[01] = r1
	19020100  // r2 = mem[01]; PC = 27
];


//############################################
// Verifiable conditions
//############################################
#define correct_branching r[1] == 1 && r[2] == 2 && r[3] == 2 && r[4] == 25 && r[5] == 25 && r[6] == 25 && pcSeq == 17;
#define correct_basic_operation r[3] == 3 && r[4] == 1 && r[5] == 6 && r[6] == 2 && pcSeq == 24;
#define correct_memory_access mem[1] == 15 && r[2] == 15 && pcSeq == 27;


//############################################
// Sequential CPU
//############################################
SeqCPU() =clk-> {
	//IF
	if (pcSeq + 1 < call(ArrayLength, program)) {
		pcSeq++;
		instr = program[pcSeq];
	} else {
		instr = -1;
	}
	
	//ID
	if (instr != -1) {
		// read register value to op3
		op3 = r[instr % 100];
		instr = instr / 100;
		
		// read register value to op2 & read immediate value to op2_imm
		op2 = r[instr % 100]; // likely out of range exception
		op2_imm = instr % 100;
		instr = instr / 100;
		
		// read register index to op1
		op1 = instr % 100;
		instr = instr / 100;
		
		// read cmd
		cmd = instr;
		
		// do branch & jump in ID stage
		if (cmd == 15) { // BEQ
			if(op2 == op3) {
				pcSeq = op1 - 1;
			}
			cmd = -1;
			memory_access = -1;
			write_back_register = -1;
		} else if (cmd == 16) { // BNE
			if(op2 != op3) {
				pcSeq = op1 - 1;
			}
			cmd = -1;
			memory_access = -1;
			write_back_register = -1;
		} else if (cmd == 17) { // JUMP
			pcSeq = op1 - 1;
			cmd = -1;
			memory_access = -1;
			write_back_register = -1;
		}
	} else {
		cmd = -1;
		op1 = -1;
		op2 = -1;
		op2_imm = -1;
		op3 = -1;
	}
	
	//EXE
	if (cmd != -1) {
		if (cmd == 10) { // NOOP
			// do nothing
			alu_out = alu_out;
			memory_access = -1;
			write_back_register = -1;
		} else if (cmd == 11) { // ADD
			alu_out = op2 + op3;
			memory_access = -1;
			write_back_register = op1;
		} else if (cmd == 12) { // SUB
			alu_out = op2 - op3;
			memory_access = -1;
			write_back_register = op1;
		} else if (cmd == 13) { // MULT
			alu_out = op2 * op3;
			memory_access = -1;
			write_back_register = op1;
		} else if (cmd == 14) { // DIV
			alu_out = op2 / op3;  // could be div-zero exception
			memory_access = -1;
			write_back_register = op1;
		} else if (cmd == 18) { // MOVE
			alu_out = op2_imm;
			memory_access = -1;
			write_back_register = op1;
		} else if (cmd == 19) { // LOAD
			memory_access = 0; // read from memo
			memory_addr = op2_imm;
			write_back_register = op1;
		} else if (cmd == 20) { // SAVE
			memory_access = 1; // write to memo
			memory_addr = op1;
			memory_value = op2;
			write_back_register = -1;
		} else {
			write_back_register = -1;
		}
	} else {
		write_back_register = -1;
	}
	
	//MEM
	if (memory_access == 0) {
		// read from memory to register
		write_back_value = mem[memory_addr];
	} else if (memory_access == 1) {
		// write to memory from register
		mem[memory_addr] = memory_value;
	} else {
		// no memory access needed
		write_back_value = alu_out;
	}
	
	//WB
	if (write_back_register != -1) {
		r[write_back_register] = write_back_value;
	}
}->SeqCPU();


//############################################
// Pipeline CPU
//############################################

/********************************************
 * IF Stage 
 ********************************************/
InstructionFetch() = clk -> IF {
	if (pc + 1 < call(ArrayLength, program)) {
		pc++;
		trans_instr = program[pc];
	} else {
		trans_instr = -1;
	}
} -> trans -> InstructionFetch();

IF2ID() = clk -> trans -> IF2ID_Trans {
	instr = trans_instr;
} -> IF2ID();

/********************************************
 * ID Stage 
 ********************************************/
InstructionDecode() = clk -> ID {
	if (instr != -1) {
		// extract op3
		trans_op3 = r[instr % 100];
		instr = instr / 100;
		// extract op2
		trans_op2 = r[instr % 100];
		instr = instr / 100;
		// extract op1
		trans_op1 = instr % 100;
		instr = instr / 100;
		// extract cmd
		trans_cmd = instr;
	} else {
		trans_cmd = -1;
		trans_op1 = -1;
		trans_op2 = -1;
		trans_op3 = -1;
	}
} -> trans -> InstructionDecode();

ID2EX() = clk -> trans -> ID2EX_Trans {
	cmd = trans_cmd;
	op1 = trans_op1;
	op2 = trans_op2;
	op3 = trans_op3;
} -> ID2EX();

/********************************************
 * EX Stage 
 ********************************************/
Execution() = clk -> EXE {
	if (cmd != -1) {
		trans_pc = -1;
		if (cmd == 10) { // NOOP
			// do nothing
			trans_alu_out = trans_alu_out;
		} else if (cmd == 11) { // ADD
			trans_alu_out = op2 + op3;
			trans_write_back_register = op1;
		} else if (cmd == 12) { // SUB
			trans_alu_out = op2 - op3;
			trans_write_back_register = op1;
		} else if (cmd == 13) { // MULT
			trans_alu_out = op2 * op3;
			trans_write_back_register = op1;
		} else if (cmd == 14) { // DIV
			trans_alu_out = op2 / op3;  // could be div-zero exception
			trans_write_back_register = op1;
		} else if (cmd == 15) { // BEQ
			if( op2 == op3){
				trans_pc = op1 - 1;
			}
			trans_write_back_register = -1;
		} else if (cmd == 16) { // BNE
			if( op2 != op3){
				trans_pc = op1 - 1;
			}
			trans_write_back_register = -1;
		} else if (cmd == 17) { // JUMP
			trans_pc = op1 - 1;
			trans_write_back_register = -1;
			// need to flush
		} else if (cmd == 18) { // MOVE
			trans_alu_out = op2;
		} else if (cmd == 19) { // LOAD
			trans_alu_out = mem[op2];
		} else if (cmd == 20) { // SAVE
			// ??
			mem[op1] = op2;
		}// else {
			// unsupported command exception
		//}
	} else {
		trans_write_back_register = -1;
	}
} -> trans -> Execution();

EX2WB() = clk -> trans -> EX2WB_Trans {
	alu_out = trans_alu_out;
	write_back_register = trans_write_back_register;
	if (trans_pc != -1){
		pc = trans_pc;
	}
} -> EX2WB();

/********************************************
 * MEM Stage 
 ********************************************/
//no MEM stage yet
 
/********************************************
 * WB Stage 
 ********************************************/
WriteBack() = clk -> WB {
	if (write_back_register != -1) {
		r[write_back_register] = alu_out;
	}
} -> trans -> WriteBack();

/********************************************
 * Pipelining each stage and transition
 ********************************************/
StageTransition() = IF2ID() || ID2EX() || EX2WB();
PipelineCPU() = InstructionFetch() || InstructionDecode() || Execution() || WriteBack() || StageTransition();


//############################################
// Verification
//############################################

#assert PipelineCPU() reaches correct_basic_operation;
#assert PipelineCPU() reaches correct_branching;
#assert PipelineCPU() reaches correct_memory_access;
#assert SeqCPU() reaches correct_basic_operation;
#assert SeqCPU() reaches correct_branching;
#assert SeqCPU() reaches correct_memory_access;
